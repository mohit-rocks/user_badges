<?php
/**
 * @file
 * Hooks and other stuff related to user badge.
 */

// Admin uri links.
/*define('admin/content/user_badge/manage/', 'admin/content/user_badge/manage/');
define('admin/content/user_badge', 'admin/content/user_badge');
define('USER_BADGES_ADMIN_PATH', 'admin/config/user_badges');*/
define('USER_BADGES_SAVE_ERROR', -1);
define('USER_BADGES_SAVE_SUCCESS', 1);
define('USER_BADGES_NOT_MODIFIED', 2);

/**
 * Implements hook_views_api().
 */
function user_badges_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_init().
 */
function user_badges_init() {
  // Add any other module that can initiate actions.
  if (\Drupal::moduleHandler()->moduleExists('trigger') || \Drupal::moduleHandler()->moduleExists('rules')) {
    module_load_include('inc', 'user_badges', 'user_badges.actions');
  }
  // Attention: Removed autossigned code. Don't know implications.
}

/**
 * Implements hook_entity_info().
 */
function user_badges_entity_info() {
  $user_badge_entity_info['user_badge'] = array(
    'label' => t('User Badge'),
    'label callback' => 'user_badges_label_callback',
    'view callback' => 'user_badge_view_multiple',
    'entity class' => 'UserBadge',
    'controller class' => 'UserBadgeController',
    'base table' => 'user_badge',
    'uri callback' => 'user_badges_uri',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'bid',
      'label' => 'name',
    ),
    'load hook' => 'user_badges_load',
    'static cache' => TRUE,
    'admin ui' => array(
      'path' => 'admin/content/user_badge',
      'controller class' => 'UserBadgeUIController',
      'file' => 'includes/user_badges.admin.inc',
    ),
    'module' => 'user_badges',
    'views controller class' => 'UserBadgeViewsController',
    'access callback' => 'user_badges_access_callback',
    'bundles' => array(
      'user_badge' => array(
        'label' => 'User Badge',
        'admin' => array(
          'path' => 'admin/content/user_badge/manage/',
          'access arguments' => array('administer user badges'),
        ),
      ),
    ),
    'view modes' => array(
      'default' => array(
        'label' => t('Default'),
        'custom settings' => TRUE,
      ),
      'full' => array(
        'label' => t('Full User Badge'),
        'custom settings' => TRUE,
      ),
      'teaser' => array(
        'label' => t('Teaser'),
        'custom settings' => TRUE,
      ),

    ),
  );

  return $user_badge_entity_info;
}

/**
 * Implements hook_menu().
 */
function user_badges_menu() {
  $items = array();

  $items['user-badge/%user_badge'] = array(
    'title' => 'User Badge',
    'page callback' => 'user_badges_view_entity',
    'page arguments' => array(1),
    'access callback' => 'user_badges_access_menu_callback',
    'access arguments' => array('view', 1),
  );

  $items['admin/structure/user_badges'] = array(
    'title' => 'User Badge Fields',
    'access arguments' => array('administer user badge entities'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/content/user_badge/bulk/delete/%'] = array(
    'title' => 'Bulk Delete User Badges',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_badges_bulk_delete', 5),
    'access arguments' => array('administer user badge entities'),
    'file' => 'includes/user_badges.admin.inc',
  );

  $items['admin/config/user_badges'] = array(
    'title' => 'User Badges Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_badges_settings_form'),
    'access arguments' => array('manage badges'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/user_badges.admin.inc',
    'weight' => 0,
  );

  $items['admin/config/user_badges/settings'] = array(
    'title' => 'User Badges Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/config/user_badges/roles'] = array(
    'title' => 'Roles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_badges_roles_form'),
    'access arguments' => array('manage badges'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/user_badges.admin.inc',
    'weight' => 1,
  );

  $items['user/%user/badges'] = array(
    'title' => 'Badges',
    'page callback' => 'user_badges_userweight_page',
    'page arguments' => array(1),
    'access arguments' => array('change badge assignments'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
  );

  $items['user/%user/badges/list'] = array(
    'title' => 'List',
    'page callback' => 'user_badges_userweight_page',
    'page arguments' => array(1),
    'access arguments' => array('change badge assignments'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['user/%user/badges/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'user_badges_page',
    'page arguments' => array(1),
    'access arguments' => array('change badge assignments'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['user/%user/edit/badges'] = array(
    'title' => 'Badges',
    'page callback' => 'user_badges_page',
    'page arguments' => array(1),
    'access arguments' => array('change badge assignments'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function user_badges_form_user_profile_form_alter(&$form, &$form_state) {
  // We need to hide this field from user profile form.
  // This should be modified only in provided UI for keeping consistency.
  $form['user_badge_badges']['#access'] = FALSE;
}

/**
 * Check access permission for User Badge Entity UI.
 */
function user_badges_access_menu_callback($op, $user_badge = NULL, Drupal\Core\Session\AccountInterface $account = NULL) {
  switch ($op) {
    case 'view':
      return $account->hasPermission('view user badge entities');

    case 'create':
      return $account->hasPermission('create user badge entities');

    case 'update':
      return $account->hasPermission('edit user badge entities');

    case 'delete':
      return $account->hasPermission('delete user badge entities');

  }
  return FALSE;
}

/**
 * Return user_badge label.
 */
function user_badges_label_callback($user_badge, $type) {
  return empty($user_badge->name) ? 'Untitled User Badge' : \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name);
}

/**
 * Saves user_badge to database.
 */
function user_badge_save(UserBadge $user_badge) {
  return $user_badge->save();
}

/**
 * Menu autoloader for user_badge.
 */
function user_badge_load($bid, $reset = FALSE) {
  $user_badge = user_badge_load_multiple(array($bid), array(), $reset);
  return reset($user_badge);
}

/**
 * Load multiple user_badge based on certain conditions.
 */
function user_badge_load_multiple($bids = array(), $conditions = array(), $reset = FALSE) {
  return \Drupal::entityManager()->getStorage('user_badge')->loadByProperties($conditions);
}

/**
 * Deletes a user_badge.
 */
function user_badge_delete(UserBadge $user_badge) {
  $user_badge->delete();
}

/**
 * Delete multiple user_badge.
 */
function user_badge_delete_multiple(array $bids) {
  entity_get_controller('user_badge')->delete($bids);
}

/**
 * Access callback function.
 */
function user_badges_access_callback() {
  if (\Drupal::currentUser()->isAnonymous() && !\Drupal::currentUser()->hasPermission('administer user badge entities')) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Implements callback_entity_info_uri().
 */
function user_badges_uri($user_badge) {
  return array(
    'path' => 'user-badge/' . $user_badge->bid,
  );
}

/**
 * View for /user-badge/<bid> page.
 */
function user_badges_view_entity($user_badge) {
  $name = $user_badge->name;
  // @FIXME
// drupal_set_title() has been removed. There are now a few ways to set the title
// dynamically, depending on the situation.
//
//
// @see https://www.drupal.org/node/2067859
// drupal_set_title($name);

  $uri = entity_uri('user_badge', $user_badge);
  // Set the node path as the canonical URL to prevent duplicate content.
  // @FIXME
// url() expects a route name or an external URI.
// drupal_add_html_head_link(array(
//     'rel' => 'canonical',
//     'href' => url($uri['path'],
//     $uri['options'])), TRUE);

  // Set the non-aliased path as a default shortlink.
  // @FIXME
// url() expects a route name or an external URI.
// drupal_add_html_head_link(array(
//     'rel' => 'shortlink',
//     'href' => url($uri['path'], array_merge($uri['options'], array('alias' => TRUE)))), TRUE);

  return user_badges_show($user_badge);
}

/**
 * User badge show.
 */
function user_badges_show($user_badge, $message = FALSE) {
  // For markup consistency with other pages, use user_badge_view_multiple()
  // rather than user_badge_view().
  $user_badge = user_badge_view_multiple(array($user_badge->bid => $user_badge), 'full');
  return $user_badge;
}

/**
 * Constructs a drupal_render() style array from an array of loaded user_badge.
 *
 * @param array $user_badges
 *   An array of nodes as returned by node_load_multiple().
 * @param string $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param int $weight
 *   An integer representing the weight of the first node in the list.
 * @param string $langcode
 *   (optional) A language code to use for rendering. Defaults to NULL which is
 *   the global content language of the current request.
 *
 * @return array
 *   An array in the format expected by drupal_render().
 */
function user_badge_view_multiple($user_badges, $view_mode = 'teaser', $weight = 0, $langcode = NULL) {
  field_attach_prepare_view('user_badge', $user_badges, $view_mode, $langcode);
  entity_prepare_view('user_badge', $user_badges, $langcode);
  $build = array();
  foreach ($user_badges as $user_badge) {
    $build['user_badges'][$user_badge->bid] = user_badge_view($user_badge, $view_mode, $langcode);
    $build['user_badges'][$user_badge->bid]['#weight'] = $weight;
    $weight++;
  }
  $build['user_badges']['#sorted'] = TRUE;
  return $build;
}

/**
 * Generates an array for rendering the given user_badge.
 *
 * @param UserBadge $user_badge
 *   An user_badge object.
 * @param string $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param string $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return array
 *   An array as expected by drupal_render().
 */
function user_badge_view($user_badge, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Populate $user_badge->content with a render() array.
  user_badge_build_content($user_badge, $view_mode, $langcode);

  $build = $user_badge->content;
  // We don't need duplicate rendering info in user_badge->content.
  unset($user_badge->content);

  $build += array(
    '#theme' => 'user_badge',
    '#user_badge' => $user_badge,
    '#view_mode' => $view_mode,
    '#language' => $langcode,
  );

  // Allow modules to modify the structured node.
  $type = 'user_badge';
  \Drupal::moduleHandler()->alter(array('user_badge_view', 'entity_view'), $build, $type);

  return $build;
}


/**
 * Builds a structured array representing the user_badge's content.
 *
 * @param UserBadge $user_badge
 *   A user_badge object.
 * @param string $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param string $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 */
function user_badge_build_content($user_badge, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Remove previously built content, if exists.
  $user_badge->content = array();

  // Allow modules to change the view mode.
  $context = array(
    'entity_type' => 'user_badge',
    'entity' => $user_badge,
    'langcode' => $langcode,
  );
  \Drupal::moduleHandler()->alter('entity_view_mode', $view_mode, $context);

  // Build fields content.
  // In case of a multiple view, user_badge_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('user_badge', array($user_badge->bid => $user_badge), $view_mode, $langcode);
  entity_prepare_view('user_badge', array($user_badge->bid => $user_badge), $langcode);
  $user_badge->content += field_attach_view('user_badge', $user_badge, $view_mode, $langcode);

  // Allow modules to make their own additions to the user_badge.
  \Drupal::moduleHandler()->invokeAll('user_badge_view', [$user_badge, $view_mode, $langcode]);
  \Drupal::moduleHandler()->invokeAll('entity_view', [$user_badge, 'user_badge', $view_mode, $langcode]);

  // Make sure the current view mode is stored if no module has already
  // populated the related key.
  $user_badge->content += array('#view_mode' => $view_mode);
}

/**
 * Implements hook_theme().
 */
function user_badges_theme() {
  return array(
    'user_badge' => array(
      'render element' => 'elements',
      'template' => 'templates/user-badge',
    ),
    'user_badge_group' => array(
      'variables' => array('badgeimages' => array()),
    ),
    'user_badges_userweight_form' => array(
      'render element' => 'form',
    ),
    'user_badges_badgelist_form' => array(
      'render element' => 'form',
    ),
  );
}


/**
 * Form for users to weight their own badges.
 */
function user_badges_userweight_form($form, $form_state, $account) {
  $allbadges = array();
  $query = db_select('user_badges_assignment', 'uba');
  $results = $query->fields('uba', array('bid', 'weight'))
    ->condition('uba.uid', $account->uid, '=')
    ->orderBy('uba.weight', 'ASC')
    ->execute();
  while ($record = $results->fetchAssoc()) {
    $badge = new stdClass();
    $badge->bid = $record['bid'];
    $badge->name = user_badge_load($record['bid'])->name;
    $badge->weight = $record['weight'];
    $allbadges[] = $badge;
  }

  // Header row for the badge reweighting list.
  $form['header'] = array(
    '#type' => 'value',
    '#value' => array(
      array('data' => t('Name')),
      array('data' => t('View')),
      array('data' => t('Weight')),
    ),
  );

  // At this moment we don't have fixed weight functionality.

  // Build a table listing the appropriate badges.
  $vars = array('account' => $account);
  foreach ($allbadges as $user_badge) {

    $form['name'][$user_badge->bid] = array('#markup' => \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name));
    // @FIXME
// l() expects a Url object, created from a route name or external URI.
// $form['view'][$user_badge->bid] = array('#markup' => l(t('View'), 'user-badge/' . $user_badge->bid));


    $form['weight'][$user_badge->bid] = array(
      '#type' => 'weight',
      '#default_value' => $user_badge->weight,
      '#delta' => '5',
      '#tree' => TRUE,
      '#attributes' => array('class' => array('user_badges_userweight_element')),
    );
  }

  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $account->uid,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configuration'),
  );

  return $form;
}

/**
 * Submit function for userweights.
 */
function user_badges_userweight_form_submit($form, &$form_state) {
  $values = $form_state['values'];
  $uid = $values['uid'];
  $record = array(
    'uid' => $uid,
  );
  $primary_keys = array('uid', 'bid');
  $table_name = 'user_badges_assignment';
  // Reorder values array.
  asort($values);
  $ewrapper = entity_metadata_wrapper('user', $uid);
  $user_badges = $ewrapper->user_badge_badges->value();
  $ordered_user_badges = array();
  foreach ($values as $key => $value) {
    if (is_numeric($key)) {
      $record['bid'] = $key;
      $record['weight'] = $value;
      $result = \Drupal::database()->merge($table_name)->fields($record)->key($primary_keys)->execute();
      foreach ($user_badges as $user_badge) {
        if ($user_badge->bid == $key) {
          $ordered_user_badges[] = $key;
          break;
        }
      }
    }
  }
  $ewrapper->user_badge_badges->set($ordered_user_badges);
  $ewrapper->save();
}

/**
 * Form theming function.
 */
function theme_user_badges_userweight_form($variables) {
  $form = $variables['form'];
  $output = '';

  // Loop through the array items in the name array to
  // get all the bids for our listed badges.
  if (isset($form['name']) && is_array($form['name'])) {
    foreach (\Drupal\Core\Render\Element::children($form['name']) as $key) {
      // We only want bids as values of $key.
      if (!is_numeric($key)) {
        continue;
      }

      // Create the rows array for the table theme.
      $row = array();
      $row[] = \Drupal::service("renderer")->render($form['name'][$key]);
      $row[] = \Drupal::service("renderer")->render($form['view'][$key]);
      $row[] = \Drupal::service("renderer")->render($form['weight'][$key]);
      // Add the draggable class to this row.
      $rows[] = array(
        'data' => $row,
        'class' => array('draggable'),
        '#weight' => $form['weight'][$key]['#value'],
      );
    }

    // Sort the rows by their weights.
    usort($rows, 'element_sort');

    // Add the submit button.
    $row = array();
    $row[] = '';
    $row[] = \Drupal::service("renderer")->render($form['submit']);
    $row[] = '';
    $rows[] = $row;

  }
  else {
    $rows[] = array(
      array(
        'data' => t('No badges available.'),
        'colspan' => '3',
      ),
    );
  }

  // This makes the table draggable.
  // @FIXME
// TableDrag is now attached with the #tabledrag property of certain render
// arrays. drupal_add_tabledrag() is now internal and should never be called directly.
//
//
// @see https://www.drupal.org/node/2160571
// drupal_add_tabledrag('user_badges_userweight', 'order', 'sibling', 'user_badges_userweight_element');


  // Theme all that we have processed so far into a table.
  // @FIXME
// theme() has been renamed to _theme() and should NEVER be called directly.
// Calling _theme() directly can alter the expected output and potentially
// introduce security issues (see https://www.drupal.org/node/2195739). You
// should use renderable arrays instead.
//
//
// @see https://www.drupal.org/node/2195739
// $output .= theme('table',
//     array(
//       'header' => $form['header']['#value'],
//       'rows' => $rows,
//       'attributes' => array('id' => 'user_badges_userweight'),
//     )
//   );


  // Render any remaining form elements.
  $output .= drupal_render_children($form);

  return $output;

}

/**
 * Define the badges edit page.
 */
function user_badges_page(\Drupal\user\UserInterface $account) {
  // @FIXME
// drupal_set_title() has been removed. There are now a few ways to set the title
// dynamically, depending on the situation.
//
//
// @see https://www.drupal.org/node/2067859
// drupal_set_title(t('Edit badges for %user_name', array('%user_name' => $account->name)), PASS_THROUGH);


  return \Drupal::formBuilder()->getForm('user_badges_change_form', $account);
}

/**
 * Define the page on user/uid/badges.
 */
function user_badges_userweight_page(\Drupal\user\UserInterface $account) {
  $user = \Drupal::currentUser();

  // @FIXME
// drupal_set_title() has been removed. There are now a few ways to set the title
// dynamically, depending on the situation.
//
//
// @see https://www.drupal.org/node/2067859
// drupal_set_title(t('Badges for %user_name', array('%user_name' => format_username($account))), PASS_THROUGH);


  // Do we have the right to rearrange badges?
  if (\Drupal::config('user_badges.settings')->get('user_badges_userweight') && ($account->id() == $user->uid || \Drupal::currentUser()->hasPermission('change badge assignments'))) {
    // If the setting allows it and we are the badge owner
    // or somebody with permission, yes.
    return \Drupal::formBuilder()->getForm('user_badges_userweight_form', $account);
  }
  else {
    return views_embed_view('user_badges_user', 'badges_list', $account->id());
  }
}

/**
 * Form to change badges of a user.
 */
function user_badges_change_form($form, &$form_state, $account) {
  $form = array();

  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $account->uid,
  );

  $form['add'] = array(
    '#type' => 'fieldset',
    '#title' => t('Add Badges'),
    '#weight' => 3,
    '#tree' => TRUE,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  // Determine which selector type the user wants to use to
  // set badges from their settings
  // If the user wants to use the drop-down selector,
  // display that if there are records in the db.
  if (\Drupal::config('user_badges.settings')->get('user_badges_selector_type') == 0) {

    // Display the drop-down only if we get any records.
    $options = user_badges_get_badges('select');

    // Initialize the $options array,
    // which will contain all the badges fetched from the db
    // Add a - None - option to the badge list as Drupal core
    // won't give it to us automatically because it is a multi select list!!
    $options[-1] = '- None -';

    // Add the drop-down multi select box to add badges.
    $form['add']['add_drop_down'] = array(
      '#type' => 'select',
      '#title' => t('New Badges'),
      '#options' => $options,
      '#multiple' => TRUE,
    );
  }
  // Else, if the user wants to use the autocomplete box to
  // set badges or if there are no records in the db,
  // then, display, 5 autocomplete boxes for them to select from.
  else {
    for ($i = 1; $i <= 5; $i++) {
      // Add the autocomplete boxes to add badges.
      $form['add'][$i] = array(
        '#type' => 'textfield',
        '#title' => t('New Badge @number', array('@number' => $i)),
        '#size' => 40,
        '#maxlength' => 255,
        '#autocomplete_path' => 'entityreference/autocomplete/single/user_badge_badges/user/user/NULL',
      );
    }
  }

  $user_badges = user_badges_get_badges($account->uid);
  if (count($user_badges)) {
    $form['remove'] = array(
      '#type' => 'fieldset',
      '#title' => t('Remove Badges'),
      '#weight' => 5,
      '#tree' => TRUE,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    foreach ($user_badges as $key => $user_badge) {
      $form['remove'][$key] = array(
        '#type' => 'checkbox',
        '#title' => \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name),
        '#return_value' => 1,
        '#default_value' => 0,
        '#description' => t('Tick to remove %badge_name from this user', array('%badge_name' => \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name))),
      );
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update Badges'),
    '#weight' => 10,
  );

  return $form;
}

/**
 * Helper function to load all the badges from the database.
 *
 * @return array
 *   An array of badge objects
 */
function user_badges_load_badges() {
  // Load all the available badges from the database.
  $efq = new EntityFieldQuery();
  $results = $efq->entityCondition('entity_type', 'user_badge')
    ->execute();
  $bids = !empty($results['user_badge']) ? array_keys($results['user_badge']) : array();

  $result = user_badge_load_multiple($bids);

  return $result;
}

/**
 * Validate user_badges_remove_form form submissions.
 */
function user_badges_change_form_validate($form, &$form_state) {
  // If the user used the autocomplete to select badges;
  // change it for bid
  if (\Drupal::config('user_badges.settings')->get('user_badges_selector_type') == 1) {
    $values = &$form_state['values'];
    foreach ($values['add'] as $key => &$value) {
      $parts = explode('(', $value);
      $value = substr(end($parts), 0, -1);
    }
  }
}

/**
 * Process user_badges_change_form form submissions.
 *
 * Add the named badge. Remove the checked badges.
 */
function user_badges_change_form_submit($form, &$form_state) {
  $uid = $form_state['values']['uid'];
  // If the user used the multi drop-down to select badges,
  // submit them accordingly.
  if (\Drupal::config('user_badges.settings')->get('user_badges_selector_type') == 0) {
    foreach ($form_state['values']['add_drop_down'] as $bid) {
      // We have to add this validation as we don't want to add the - None -
      // case which might have been selected.
      if ($bid > 0) {
        user_badges_user_add_badge($uid, $bid, 'user');
      }
    }
  }
  // Else, if the user used the autocomplete to select badges,
  // submit them accordingly.
  else {
    // Add badges for non-empty fields.
    for ($i = 1; $i <= 5; $i++) {
      if (!empty($form_state['values']['add'][$i])) {
        user_badges_user_add_badge($uid, $form_state['values']['add'][$i], 'user');
      }
    }
  }

  // Remove any checked badges.
  $badges_to_go = array();
  if (isset($form_state['values']['remove'])) {
    foreach ($form_state['values']['remove'] as $bid => $value) {
      if (is_numeric($bid) && $value == 1) {
        $badges_to_go[] = $bid;
      }
    }
    if (count($badges_to_go)) {
      foreach ($badges_to_go as $bid) {
        user_badges_user_remove_badge($uid, $bid);
      }
      drupal_set_message(\Drupal::translation()->formatPlural(count($badges_to_go), '1 badge removed.', '@count badges removed.'));
    }
  }

  if (arg(2) == 'edit') {
    // My account.
    $form_state['redirect'] = "user/$uid";
  }
  else {
    // Full admin UI.
    $form_state['redirect'] = "user/$uid/badges";
  }
}

/**
 * Add a badge to user.
 *
 * @param int $uid
 *   User ID.
 * @param int $bid
 *   Badge ID.
 * @param int $type
 *   Whether set as part of the role, or individually assigned ('user', 'role').
 *   If it is string 'user' or 'role' is converted to int for compatibility.
 *
 * @return int
 *   USER_BADGES_SAVE_ERROR, USER_BADGES_SAVE_SUCCESS
 *   or USER_BADGES_NOT_MODIFIED
 */
function user_badges_user_add_badge($uid, $bid, $type = 1, $weight = 0, $source = -1) {
  // Integrate rules events.
  if (\Drupal::moduleHandler()->moduleExists('rules')) {
    $variables = array('user' => $uid, 'badge_id' => $bid);
    rules_invoke_event_by_args('user_badges_badge_given', $variables);
  }
  if ($type == 'user') {
    $type = 1;
  }
  elseif ($type == 'role') {
    $type = 2;
  }
  $ewrapper = entity_metadata_wrapper('user', $uid);
  $exists = FALSE;
  foreach ($ewrapper->user_badge_badges->value() as $index => $user_badge) {
    if ($user_badge->bid === $bid) {
      $exists = TRUE;
      break;
    }
  }
  if (!$exists) {
    $ewrapper->user_badge_badges[] = $bid;
    try {
      $ewrapper->save();
      $record = array(
        'uid' => $uid,
        'bid' => $bid,
        'weight' => $weight,
        'type' => $type,
      );
      \Drupal::database()->insert('user_badges_assignment')->fields($record)->execute();
      if ($source === -1) {
        $user = \Drupal::currentUser();
        if ($user->uid) {
          $source = $user->uid;
        }
        else {
          $source = 0;
        }
      }
      \Drupal::moduleHandler()->invokeAll('user_assign_badge', [$uid, $bid, $type, $weight, $source]);
    }
    catch (EntityMetadataWrapperException $e) {
      return USER_BADGES_SAVE_ERROR;
    }
    return USER_BADGES_SAVE_SUCCESS;
  }
  else {
    return USER_BADGES_NOT_MODIFIED;
  }
}

/**
 * Remove a badge from user.
 *
 * @param int $uid
 *   User ID.
 * @param int $bid
 *   Badge ID.
 * @param int $type
 *   Whether set as part of the role, or individually assigned ('user', 'role').
 *   At this moment it's not used; because we don't care how was it set for
 *   removing.
 *
 * @return int
 *   Operation status
 */
function user_badges_user_remove_badge($uid, $bid, $type = NULL, $source = -1) {
  // Integrate rules events.
  if (\Drupal::moduleHandler()->moduleExists('rules')) {
    $variables = array('user' => $uid, 'badge_id' => $bid);
    rules_invoke_event_by_args('user_badges_badge_removed', $variables);
  }
  $ewrapper = entity_metadata_wrapper('user', $uid);
  $updated = FALSE;
  foreach ($ewrapper->user_badge_badges->getIterator() as $delta => $user_badge_wrapper) {
    if ($user_badge_wrapper->value()->bid == $bid) {
      $ewrapper->user_badge_badges[$delta]->set(NULL);
      try {
        $ewrapper->save();
        $updated = TRUE;
      }
      catch (EntityMetadataWrapperException $e) {
        return USER_BADGES_SAVE_ERROR;
      }
      break;
    }
  }
  if ($updated) {
    db_delete('user_badges_assignment')
      ->condition('uid', $uid)
      ->condition('bid', $bid)
      ->execute();
    if ($source === -1) {
      $user = \Drupal::currentUser();
      if ($user->uid) {
        $source = $user->uid;
      }
      else {
        $source = 0;
      }
    }
    \Drupal::moduleHandler()->invokeAll('user_delete_badge', [$uid, $bid, $source]);
    return USER_BADGES_SAVE_SUCCESS;
  }
  return USER_BADGES_NOT_MODIFIED;
}

/**
 * Return array of user badges.
 *
 * @param int $uid
 *   if $uid is a user id, returns badges for that user.
 *   if $uid is 'all', returns all badges.
 *   if $uid is 'select', returns badges for form_select options.
 * @param array $options
 *   array of options.
 *   Actually not used. Just for compatibility.
 *
 * @return array
 *   Array of badges in desired format.
 */
function user_badges_get_badges($uid, $options = array()) {
  if ($uid == 'all') {
    $efq = new EntityFieldQuery();
    $results = $efq->entityCondition('entity_type', 'user_badge')
      ->execute();
    $bids = !empty($results['user_badge']) ? array_keys($results['user_badge']) : array();
    $user_badges = user_badge_load_multiple($bids);
    return $user_badges;
  }
  elseif ($uid == 'select') {
    $efq = new EntityFieldQuery();
    $results = $efq->entityCondition('entity_type', 'user_badge')
      ->execute();
    $bids = !empty($results['user_badge']) ? array_keys($results['user_badge']) : array();
    $user_badges = user_badge_load_multiple($bids);
    $options = array();
    foreach ($user_badges as $key => $user_badge) {
      $options[$key] = \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name);
    }
    return $options;
  }
  else {
    $ewrapper = entity_metadata_wrapper('user', $uid);
    $user_badges = array();
    foreach ($ewrapper->user_badge_badges->value() as $index => $user_badge) {
      if ($user_badge) {
        $bid = $user_badge->bid;
        $query = db_select('user_badges_assignment', 'uba');
        $weight = $query->fields('uba', array('weight'))
          ->condition('uba.bid', $bid)
          ->condition('uba.uid', $uid)
          ->execute()
          ->fetchField(0);
        $user_badge->weight = $weight;
        $user_badges[$bid] = $user_badge;
      }
    }
    return $user_badges;
  }
}

/**
 * Return array $rid => $bid.
 *
 * @param array $rids
 *   if set, return only values for this role
 *
 * @param array $options
 *   array of options
 *   $options['returnbadges'] - if TRUE, return badge objects, not just bids
 *
 * @return array
 *   a list of roles pt the whole badge object.
 */
function user_badges_get_roles($rids = NULL, $options = array()) {
  $roles_badges = array();
  $options = array_merge(array('returnbadges' => FALSE), $options);

  if (count($rids)) {
    $rids = array_keys($rids);
  }
  else {
    $roles = user_roles(TRUE);
    $rids = array_keys($roles);
  }

  $user_badge_roles = \Drupal::config('user_badges.settings')->get('user_badges_role');
  foreach ($rids as $rid) {
    if (isset($user_badge_roles[$rid]) && $user_badge_roles[$rid]) {
      $bid = $user_badge_roles[$rid] ? $user_badge_roles[$rid] : 0;
      if ($options['returnbadges']) {
        $roles_badges[$rid] = user_badge_load($bid);
      }
      else {
        $roles_badges[$rid] = $bid;
      }
    }
  }

  // Let's add blocked user badge to this array.
  $bid = \Drupal::config('user_badges.settings')->get('user_badges_blocked_badge');
  if ($bid) {
    if ($options['returnbadges']) {
      $roles_badges['blocked'] = user_badge_load($bid);
    }
    else {
      $roles_badges['blocked'] = \Drupal::config('user_badges.settings')->get('user_badges_blocked_badge');
    }
  }

  return $roles_badges;
}

/**
 * Implements hook_cron().
 */
function user_badges_cron() {
  // @FIXME
// Could not extract the default value because it is either indeterminate, or
// not scalar. You'll need to provide a default value in
// config/install/user_badges.settings.yml and config/schema/user_badges.schema.yml.
$roles = \Drupal::config('user_badges.settings')->get('user_badges_role');

  // Ensure all users have the correct badges.
  foreach ($roles as $rid => $bid) {
    if ($bid) {
      user_badges_add_role_based_badge($bid, $rid);
    }
  }

  $blocked = \Drupal::config('user_badges.settings')->get('user_badges_blocked_badge');
  if ($blocked) {
    user_badges_add_role_based_badge($bid, FALSE, TRUE);
  }

  // Remove any old badges.
  user_badges_ensure_old_roles_badges_removed($roles, $blocked);
}

/**
 * Selects all users to remove role-based badges from.
 *
 * @param int $bid The badge id we are adding to.
 * @param int $rid The role id we are adding the corresponding badge to.
 * @param int $blocked The id of the blocked user bid. If included, we will
 *                     ignore the rid.
 *
 * @return null.
 */
function user_badges_add_role_based_badge($bid, $rid = FALSE, $blocked = FALSE) {
  $user_badge = user_badge_load($bid);
  if ($rid == 2) {
    $query = db_select('users', 'u')
      ->condition('u.status', 1, '=');
  }
  elseif ($blocked) {
    $query = db_select('users', 'u')
      ->condition('status', 0, '=')
      ->condition('uid', 1, '>');
  }
  else {
    $query = db_select('users_roles', 'u')
      ->condition('u.rid', $rid, '=');
  }

  $sub_query = db_select('user_badges_assignment', 'ub')
    ->fields('ub', array('uid'))
    ->condition('bid', $bid, '=');

  $results = $query->fields('u', array('uid'))
    ->condition('uid', $sub_query, 'NOT IN')
    ->execute()
    ->fetchCol();

  foreach ($results as $uid) {
    $retun = user_badges_user_add_badge($uid, $bid, 2, $user_badge->weight, 0);
  }
}

/**
 * A function to ensure that we remove automatically assigned badges.
 *
 * @param  array $roles An array of the roles and their bid (if any).
 * @param  int $blocked The bid of the blocked user badge (if one).
 * @return null
 */
function user_badges_ensure_old_roles_badges_removed($roles, $blocked = FALSE) {

  // First we grab all user badges that are assigned automatically.
  $query = db_select('user_badges_assignment', 'uba');
  $badges = $query->fields('uba', array('bid'))
    ->condition('uba.type', 2, '=')
    ->groupBy('uba.bid')
    ->execute()
    ->fetchAll();

  $remove_badges = array();

  // Go through each badge, each that are not assigned to a role, we remove.
  foreach($badges as $badge) {
    if ($badge->bid != $blocked && !in_array($badge->bid, $roles)) {
      $remove_badges[] = $badge->bid;
    }
  }

  // TODO: Automatic removal of badges from users whose role was taken away.
  // This can either be done here, or in a hook_user_update (?) function.

  // If we have some badges, then we will remove them. We don't want to do this
  // straight away, because it might go through MANY users who have badges
  // assigned.
  if (!empty($remove_badges)) {
    $query = db_select('user_badges_assignment', 'uba');
    $badges = $query->fields('uba', array('bid', 'uid'))
      ->condition('uba.type', 2, '=')
      ->condition('uba.bid', $remove_badges, 'IN')
      ->execute()
      ->fetchAll();

    foreach($badges as $badge) {
      user_badges_user_remove_badge($badge->uid, $badge->bid, NULL, 0);
    }
  }
}

/**
 * Ensures all users who are blocked have the blocked badge.
 */
function user_badges_add_blocked_badge($bid) {
  $user_badge = user_badge_load($bid);
  $query = db_select('users', 'u');

  $sub_query = db_select('user_badges_assignment', 'ub')
    ->fields('ub', array('uid'))
    ->condition('bid', $bid, '=');

  $results = $query->fields('u', array('uid'))
    ->condition('status', 0, '=')
    ->condition('uid', 1, '>')
    ->condition('uid', $sub_query, 'NOT IN')
    ->execute()
    ->fetchCol();


  foreach ($results as $uid) {
    user_badges_user_add_badge($uid, $bid, 2, $user_badge->weight, 0);
  }
}


/**
 * Returns TRUE if this is full view.
 */
function user_badge_is_page($user_badge) {
  $page_user_badge = \Drupal::routeMatch()->getParameter('user_badge');
  return (!empty($page_user_badge) ? $page_user_badge->bid == $user_badge->bid : FALSE);
}

/**
 * Processes variables for user-badge.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $user_badge
 * - $view_mode
 * - $page
 *
 * @see user-badge.tpl.php
 */
function template_preprocess_user_badge(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  // Provide a distinct $teaser boolean.
  $variables['teaser'] = $variables['view_mode'] == 'teaser';
  $variables['user_badge'] = $variables['elements']['#user_badge'];
  $user_badge = $variables['user_badge'];

  $variables['date']      = format_date($user_badge->created);
  $uri = entity_uri('user_badge', $user_badge);
  // @FIXME
// url() expects a route name or an external URI.
// $variables['user_badge_url']  = url($uri['path'], $uri['options']);

  $variables['name']     = \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name);
  $variables['page']      = $variables['view_mode'] == 'full' && user_badge_is_page($user_badge);

  // Flatten the user_badge object's member fields.
  $variables = array_merge((array) $user_badge, $variables);

  // Helpful $content variable for templates.
  $variables += array('content' => array());
  foreach (\Drupal\Core\Render\Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('user_badge', $user_badge, $variables['content'], $variables);

  // Gather user_badge classes.
  $variables['classes_array'][] = \Drupal\Component\Utility\Html::getClass('user-badge-' . str_replace(' ', '-', \Drupal\Component\Utility\SafeMarkup::checkPlain($user_badge->name)));
  if ($variables['teaser']) {
    $variables['classes_array'][] = 'user-badge-teaser';
  }
  if (isset($variables['preview'])) {
    $variables['classes_array'][] = 'user-badge-preview';
  }

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'user_badge__' . $user_badge->bid;
}








